<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Session ‚Ä¢ Digi Kul</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container-fluid">
            <a class="navbar-brand" href="/api/teacher/dashboard">
                <i class="bi bi-mortarboard me-2"></i>
                Digi Kul - Live Session
            </a>
            <div class="navbar-nav ms-auto">
                <span class="navbar-text me-3">
                    <i class="bi bi-person-circle me-1"></i>
                    Teacher
                </span>
                <button class="btn btn-outline-light" onclick="leaveSession()">
                    <i class="bi bi-box-arrow-right me-1"></i>Leave Session
                </button>
            </div>
        </div>
    </nav>

<style>
    .main-container {
        display: flex;
        height: calc(100vh - 120px);
        gap: 1rem;
    }
    
    .video-container {
        flex: 2;
        background: #000;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }
    
    .video-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1rem;
        padding: 1rem;
        height: 100%;
        overflow-y: auto;
    }
    
    .video-wrapper {
        position: relative;
        background: #333;
        border-radius: 8px;
        overflow: hidden;
        min-height: 200px;
    }
    
    .video-wrapper.teacher {
        border: 3px solid #28a745;
    }
    
    .video-wrapper.student {
        border: 2px solid #6c757d;
    }
    
    .video-wrapper video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .video-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
    }
    
    .video-controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        gap: 5px;
    }
    
    .control-btn-small {
        width: 30px;
        height: 30px;
        border: none;
        border-radius: 50%;
        background: rgba(0,0,0,0.7);
        color: white;
        font-size: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .sidebar {
        width: 350px;
        background: white;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .sidebar-tabs {
        display: flex;
        border-bottom: 1px solid #eee;
    }
    
    .sidebar-tab {
        flex: 1;
        padding: 12px;
        border: none;
        background: none;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
    }
    
    .sidebar-tab.active {
        background: #007bff;
        color: white;
    }
    
    .tab-panel {
        flex: 1;
        display: none;
        flex-direction: column;
    }
    
    .tab-panel.active {
        display: flex;
    }
    
    .polls-container {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    
    .poll-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .poll-question {
        font-weight: bold;
        margin-bottom: 1rem;
        color: #333;
    }
    
    .poll-option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        margin: 5px 0;
        background: white;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .poll-option:hover {
        background: #e9ecef;
    }
    
    .poll-option.selected {
        background: #007bff;
        color: white;
    }
    
    .poll-results {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid #ddd;
    }
    
    .poll-result-bar {
        display: flex;
        align-items: center;
        margin: 5px 0;
    }
    
    .poll-result-label {
        width: 100px;
        font-size: 12px;
    }
    
    .poll-result-progress {
        flex: 1;
        height: 20px;
        background: #e9ecef;
        border-radius: 10px;
        margin: 0 10px;
        overflow: hidden;
    }
    
    .poll-result-fill {
        height: 100%;
        background: #007bff;
        transition: width 0.3s;
    }
    
    .poll-result-count {
        width: 50px;
        text-align: right;
        font-size: 12px;
        font-weight: bold;
    }
    
    .create-poll-form {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .create-poll-form input,
    .create-poll-form button {
        width: 100%;
        padding: 8px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    
    .create-poll-form button {
        background: #007bff;
        color: white;
        border: none;
        cursor: pointer;
    }
    
    .poll-option-input {
        display: flex;
        gap: 5px;
        margin: 5px 0;
    }
    
    .poll-option-input input {
        flex: 1;
    }
    
    .poll-option-input button {
        width: auto;
        padding: 8px 12px;
        background: #dc3545;
    }
    
    .session-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0,0,0,0.8);
        padding: 10px 20px;
        border-radius: 25px;
        z-index: 1000;
    }
    
    .control-btn {
        width: 50px;
        height: 50px;
        border: none;
        border-radius: 50%;
        background: #6c757d;
        color: white;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .control-btn.active {
        background: #28a745;
    }
    
    .control-btn:hover {
        transform: scale(1.1);
    }
    
    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .alert {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 5px;
        color: white;
        font-weight: bold;
        z-index: 1001;
        display: none;
    }
    
    .alert-error {
        background: #dc3545;
    }
    
    .alert-success {
        background: #28a745;
    }
    
    @media (max-width: 768px) {
        .main-container {
            flex-direction: column;
            height: auto;
        }
        
        .sidebar {
            width: 100%;
            height: 300px;
        }
        
        .video-grid {
            grid-template-columns: 1fr;
        }
    }
</style>

<div class="main-container">
    <div class="video-container">
        <div class="video-grid" id="video-grid">
            <!-- Video elements will be added here dynamically -->
        </div>
    </div>
    
    <div class="sidebar">
        <div class="sidebar-tabs">
            <button class="sidebar-tab active" onclick="switchSidebarTab('polls')">üìä Polls</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('materials')">üìÅ Materials</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('chat')">üí¨ Chat</button>
            <button class="sidebar-tab" onclick="switchSidebarTab('participants')">üë• People</button>
        </div>
        
        <!-- Polls Panel -->
        <div id="polls-panel" class="tab-panel active">
            <div class="polls-container" id="polls-container">
                <div class="create-poll-form" id="create-poll-form">
                    <h4>Create New Poll</h4>
                    <input type="text" id="poll-question" placeholder="Enter poll question...">
                    <div id="poll-options">
                        <div class="poll-option-input">
                            <input type="text" placeholder="Option 1" class="poll-option-text">
                            <button onclick="removePollOption(this)">√ó</button>
                        </div>
                        <div class="poll-option-input">
                            <input type="text" placeholder="Option 2" class="poll-option-text">
                            <button onclick="removePollOption(this)">√ó</button>
                        </div>
                    </div>
                    <button onclick="addPollOption()">+ Add Option</button>
                    <button onclick="createPoll()">Create Poll</button>
                </div>
                <div id="polls-list">
                    <!-- Polls will be added here -->
                </div>
            </div>
        </div>
        
        <!-- Materials Panel -->
        <div id="materials-panel" class="tab-panel">
            <div class="polls-container" id="materials-container">
                <h4>Lecture Materials</h4>
                <div id="materials-list">
                    <!-- Materials will be added here -->
                </div>
            </div>
        </div>
        
        <!-- Chat Panel -->
        <div id="chat-panel" class="tab-panel">
            <div class="polls-container" id="chat-container">
                <div id="chat-messages" style="height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-bottom: 10px;">
                    <!-- Chat messages will appear here -->
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <button onclick="sendChatMessage()" style="padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Participants Panel -->
        <div id="participants-panel" class="tab-panel">
            <div class="polls-container" id="participants-container">
                <div id="participants-list">
                    <!-- Participants will be added here -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Session Controls -->
<div class="session-controls">
    <div id="participants-count">üë• 0 participants</div>
    <button class="control-btn" id="mic-btn" title="Microphone">üé§</button>
    <button class="control-btn" id="cam-btn" title="Camera">üìπ</button>
    <button class="control-btn" id="screen-btn" title="Share Screen">üñ•Ô∏è</button>
    <button class="control-btn" id="record-btn" title="Start Recording" style="background: #ffc107;">üî¥</button>
    <button class="control-btn" id="leave-btn" title="Leave Session" style="background: #dc3545;">‚ùå</button>
</div>

<div id="alert" class="alert"></div>

<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<script>
    // Global variables
    let socket = null;
    let currentUser = null;
    let sessionId = null;
    let isMuted = false;
    let isVideoOff = false;
    let isScreenSharing = false;
    let isRecording = false;
    let localStream = null;
    let peerConnections = new Map();
    let remoteStreams = new Map();
    let mediaRecorder = null;
    let recordedChunks = [];
    let currentLectureId = null;
    let polls = [];
    let userVotes = new Map();
    
    // WebRTC configuration
    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Get session ID from URL
        const pathParts = window.location.pathname.split('/');
        sessionId = pathParts[pathParts.length - 1];
        
        initializeSession();
        setupEventListeners();
    });
    
    async function initializeSession() {
        try {
            // Get user info from Flask session
            const userType = '{{ session.user_type }}';
            const userName = '{{ session.user_name }}';
            const userId = '{{ session.user_id }}';
            
            currentUser = {
                id: userId,
                type: userType,
                name: userName
            };
            
            // Connect to socket
            socket = io();
            
            // Setup socket event listeners
            setupSocketListeners();
            
            // Get user media (video and audio for teachers)
            await getUserMedia();
            
            // Join session
            socket.emit('join_session', {
                session_id: sessionId,
                user_id: userId,
                user_type: userType,
                user_name: userName
            });
            
            // Get lecture ID from server template variable
            currentLectureId = '{{ lecture_id }}';
            
            console.log('Current Lecture ID:', currentLectureId);
            
            // Load polls and materials if we have a valid lecture ID
            if (currentLectureId && currentLectureId !== 'None' && currentLectureId !== '' && currentLectureId !== 'undefined') {
                loadPolls();
                loadMaterials();
            } else {
                console.warn('No valid lecture ID found, polls will not be loaded');
            }
            
        } catch (error) {
            console.error('Failed to initialize session:', error);
            showError('Failed to join session: ' + error.message);
        }
    }
    
    function setupSocketListeners() {
        socket.on('session_info', (data) => {
            updateParticipantsList(data.participants);
            // Initiate WebRTC connections with all participants
            data.participants.forEach(participant => {
                if (participant.user_id !== currentUser.id) {
                    initiateCall(participant.user_id);
                }
            });
        });
        
        socket.on('user_joined', (data) => {
            addParticipant(data);
            document.getElementById('participants-count').textContent = `üë• ${data.participants_count} participants`;
            addChatMessage('system', `${data.user_name} joined the session`);
            
            // Initiate WebRTC connection with new user
            if (data.user_id !== currentUser.id) {
                initiateCall(data.user_id);
            }
        });
        
        socket.on('user_left', (data) => {
            removeParticipant(data.user_id);
            document.getElementById('participants-count').textContent = `üë• ${data.participants_count} participants`;
            addChatMessage('system', `${data.user_name} left the session`);
        });
        
        socket.on('webrtc_offer', async (data) => {
            await handleWebRTCOffer(data);
        });
        
        socket.on('webrtc_answer', async (data) => {
            await handleWebRTCAnswer(data);
        });
        
        socket.on('ice_candidate', async (data) => {
            await handleICECandidate(data);
        });
        
        socket.on('chat_message', (data) => {
            addChatMessage(data.user_name, data.message, data.timestamp, data.user_id === currentUser.id);
        });
        
        socket.on('poll_created', (data) => {
            polls.unshift(data.poll);
            renderPolls();
        });
        
        socket.on('poll_vote', (data) => {
            updatePollResults(data.poll_id, data.results);
        });
    }
    
    async function getUserMedia() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            
            // Create local video element
            createVideoElement(currentUser.id, localStream, true);
            
            // Enable controls
            document.getElementById('mic-btn').classList.add('active');
            document.getElementById('cam-btn').classList.add('active');
            
        } catch (error) {
            console.error('Failed to get user media:', error);
            showError('Failed to access camera/microphone');
        }
    }
    
    function createVideoElement(userId, stream, isLocal = false) {
        console.log('Creating video element for user:', userId, 'isLocal:', isLocal);
        const videoGrid = document.getElementById('video-grid');
        
        // Remove existing video for this user
        const existingVideo = document.getElementById(`video-${userId}`);
        if (existingVideo) {
            existingVideo.parentElement.remove();
        }
        
        const videoWrapper = document.createElement('div');
        videoWrapper.className = `video-wrapper ${isLocal ? 'local' : (currentUser.type === 'teacher' ? 'teacher' : 'student')}`;
        videoWrapper.id = `wrapper-${userId}`;
        
        const video = document.createElement('video');
        video.id = `video-${userId}`;
        video.srcObject = stream;
        video.autoplay = true;
        video.muted = isLocal;
        video.playsInline = true;
        
        const label = document.createElement('div');
        label.className = 'video-label';
        label.textContent = isLocal ? 'You' : `User ${userId.split('_')[1]}`;
        
        const controls = document.createElement('div');
        controls.className = 'video-controls';
        
        const micIcon = document.createElement('button');
        micIcon.className = 'control-btn-small';
        micIcon.innerHTML = 'üé§';
        micIcon.title = 'Mute/Unmute';
        
        const camIcon = document.createElement('button');
        camIcon.className = 'control-btn-small';
        camIcon.innerHTML = 'üìπ';
        camIcon.title = 'Camera On/Off';
        
        controls.appendChild(micIcon);
        controls.appendChild(camIcon);
        
        videoWrapper.appendChild(video);
        videoWrapper.appendChild(label);
        videoWrapper.appendChild(controls);
        
        videoGrid.appendChild(videoWrapper);
    }
    
    async function handleWebRTCOffer(data) {
        try {
            console.log('Handling WebRTC offer from:', data.from_user_id);
            const peerConnection = new RTCPeerConnection(rtcConfig);
            peerConnections.set(data.from_user_id, peerConnection);
            
            // Add local stream
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                console.log('Added local stream to peer connection');
            }
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log('Received remote stream from:', data.from_user_id);
                const remoteStream = event.streams[0];
                remoteStreams.set(data.from_user_id, remoteStream);
                createVideoElement(data.from_user_id, remoteStream);
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice_candidate', {
                        session_id: sessionId,
                        target_user_id: data.from_user_id,
                        candidate: event.candidate,
                        from_user_id: currentUser.id
                    });
                }
            };
            
            // Set remote description
            await peerConnection.setRemoteDescription(data.offer);
            console.log('Set remote description');
            
            // Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('Created and set local answer');
            
            // Send answer
            socket.emit('webrtc_answer', {
                session_id: sessionId,
                target_user_id: data.from_user_id,
                answer: answer,
                from_user_id: currentUser.id
            });
            console.log('Sent WebRTC answer to:', data.from_user_id);
            
        } catch (error) {
            console.error('Failed to handle WebRTC offer:', error);
        }
    }
    
    async function handleWebRTCAnswer(data) {
        try {
            const peerConnection = peerConnections.get(data.from_user_id);
            if (peerConnection) {
                await peerConnection.setRemoteDescription(data.answer);
            }
        } catch (error) {
            console.error('Failed to handle WebRTC answer:', error);
        }
    }
    
    async function handleICECandidate(data) {
        try {
            const peerConnection = peerConnections.get(data.from_user_id);
            if (peerConnection) {
                await peerConnection.addIceCandidate(data.candidate);
            }
        } catch (error) {
            console.error('Failed to handle ICE candidate:', error);
        }
    }
    
    async function createPeerConnection(targetUserId) {
        const peerConnection = new RTCPeerConnection(rtcConfig);
        peerConnections.set(targetUserId, peerConnection);
        
        // Add local stream
        if (localStream) {
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
        }
        
        // Handle remote stream
        peerConnection.ontrack = (event) => {
            console.log('Received remote stream from:', targetUserId);
            const remoteStream = event.streams[0];
            remoteStreams.set(targetUserId, remoteStream);
            createVideoElement(targetUserId, remoteStream);
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('ice_candidate', {
                    session_id: sessionId,
                    target_user_id: targetUserId,
                    candidate: event.candidate,
                    from_user_id: currentUser.id
                });
            }
        };
        
        return peerConnection;
    }
    
    async function initiateCall(targetUserId) {
        try {
            console.log('Initiating call with:', targetUserId);
            const peerConnection = await createPeerConnection(targetUserId);
            
            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Send offer
            socket.emit('webrtc_offer', {
                session_id: sessionId,
                target_user_id: targetUserId,
                offer: offer,
                from_user_id: currentUser.id
            });
            
            console.log('Sent WebRTC offer to:', targetUserId);
        } catch (error) {
            console.error('Failed to initiate call:', error);
        }
    }
    
    function setupEventListeners() {
        // Microphone toggle
        document.getElementById('mic-btn').addEventListener('click', toggleMicrophone);
        
        // Camera toggle
        document.getElementById('cam-btn').addEventListener('click', toggleCamera);
        
        // Screen sharing
        document.getElementById('screen-btn').addEventListener('click', toggleScreenShare);
        
        // Recording
        document.getElementById('record-btn').addEventListener('click', toggleRecording);
        
        // Leave session
        document.getElementById('leave-btn').addEventListener('click', leaveSession);
        
        // Chat input
        document.getElementById('chat-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
    }
    
    function toggleMicrophone() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                isMuted = !audioTrack.enabled;
                
                const btn = document.getElementById('mic-btn');
                if (isMuted) {
                    btn.classList.remove('active');
                    btn.style.background = '#dc3545';
                } else {
                    btn.classList.add('active');
                    btn.style.background = '#28a745';
                }
            }
        }
    }
    
    function toggleCamera() {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                isVideoOff = !videoTrack.enabled;
                
                const btn = document.getElementById('cam-btn');
                if (isVideoOff) {
                    btn.classList.remove('active');
                    btn.style.background = '#dc3545';
                } else {
                    btn.classList.add('active');
                    btn.style.background = '#28a745';
                }
            }
        }
    }
    
    async function toggleScreenShare() {
        try {
            if (!isScreenSharing) {
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true
                });
                
                // Stop current video track
                if (localStream) {
                    localStream.getVideoTracks().forEach(track => track.stop());
                }
                
                // Create new stream with screen share
                const newStream = new MediaStream();
                screenStream.getVideoTracks().forEach(track => newStream.addTrack(track));
                if (localStream) {
                    localStream.getAudioTracks().forEach(track => newStream.addTrack(track));
                }
                
                // Update local stream
                localStream = newStream;
                
                // Update local video element
                const localVideo = document.getElementById('local-video');
                if (localVideo) {
                    localVideo.srcObject = localStream;
                }
                
                // Update all peer connections with new stream
                peerConnections.forEach((peerConnection, userId) => {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        sender.replaceTrack(screenStream.getVideoTracks()[0]);
                    }
                });
                
                isScreenSharing = true;
                document.getElementById('screen-btn').classList.add('active');
                
                // Handle screen share end
                screenStream.getVideoTracks()[0].onended = () => {
                    toggleScreenShare();
                };
                
                console.log('Screen sharing started');
                
                // Notify students about screen sharing
                socket.emit('screen_share_started', {
                    session_id: sessionId,
                    user_id: userId
                });
            } else {
                // Stop screen sharing and restore camera
                const cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                // Stop current video track
                if (localStream) {
                    localStream.getVideoTracks().forEach(track => track.stop());
                }
                
                // Create new stream with camera
                const newStream = new MediaStream();
                cameraStream.getVideoTracks().forEach(track => newStream.addTrack(track));
                cameraStream.getAudioTracks().forEach(track => newStream.addTrack(track));
                
                // Update local stream
                localStream = newStream;
                
                // Update local video element
                const localVideo = document.getElementById('local-video');
                if (localVideo) {
                    localVideo.srcObject = localStream;
                }
                
                // Update all peer connections with new stream
                peerConnections.forEach((peerConnection, userId) => {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        sender.replaceTrack(cameraStream.getVideoTracks()[0]);
                    }
                });
                
                isScreenSharing = false;
                document.getElementById('screen-btn').classList.remove('active');
                
                console.log('Screen sharing stopped, camera restored');
                
                // Notify students about screen sharing stop
                socket.emit('screen_share_stopped', {
                    session_id: sessionId,
                    user_id: userId
                });
            }
        } catch (error) {
            console.error('Failed to toggle screen share:', error);
        }
    }

    function toggleRecording() {
        if (!isRecording) {
            startRecording();
        } else {
            stopRecording();
        }
    }

    function startRecording() {
        try {
            if (!localStream) {
                showAlert('No stream available for recording', 'error');
                return;
            }

            recordedChunks = [];
            mediaRecorder = new MediaRecorder(localStream, {
                mimeType: 'video/webm;codecs=vp9'
            });

            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = function() {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `lecture_recording_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showAlert('Recording saved successfully!', 'success');
            };

            mediaRecorder.start();
            isRecording = true;
            
            const recordBtn = document.getElementById('record-btn');
            recordBtn.innerHTML = '‚èπÔ∏è';
            recordBtn.title = 'Stop Recording';
            recordBtn.style.background = '#dc3545';
            
            showAlert('Recording started', 'success');
        } catch (error) {
            console.error('Error starting recording:', error);
            showAlert('Failed to start recording: ' + error.message, 'error');
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            
            const recordBtn = document.getElementById('record-btn');
            recordBtn.innerHTML = 'üî¥';
            recordBtn.title = 'Start Recording';
            recordBtn.style.background = '#ffc107';
            
            showAlert('Recording stopped', 'info');
        }
    }

    function updateParticipantsCount() {
        const count = document.querySelectorAll('.participant').length;
        document.getElementById('participants-count').textContent = `üë• ${count} participants`;
        
        // Update participants list
        const participantsList = document.getElementById('participants-list');
        if (participantsList) {
            participantsList.innerHTML = '';
            document.querySelectorAll('.participant').forEach(participant => {
                const name = participant.querySelector('.participant-name').textContent;
                const isTeacher = participant.classList.contains('teacher');
                const participantDiv = document.createElement('div');
                participantDiv.className = 'participant-item';
                participantDiv.innerHTML = `
                    <div class="participant-info">
                        <span class="participant-name">${name}</span>
                        ${isTeacher ? '<span class="badge bg-primary">Teacher</span>' : '<span class="badge bg-secondary">Student</span>'}
                    </div>
                `;
                participantsList.appendChild(participantDiv);
            });
        }
    }
    
    function leaveSession() {
        if (socket) {
            socket.emit('leave_session', {
                session_id: sessionId,
                user_id: currentUser.id
            });
        }
        
        // Stop local stream
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        
        // Close peer connections
        peerConnections.forEach(connection => connection.close());
        
        // Redirect to dashboard
        window.location.href = '/api/teacher/dashboard';
    }
    
    function switchSidebarTab(tabName) {
        // Hide all tab panels
        document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        
        // Remove active class from all tabs
        document.querySelectorAll('.sidebar-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Show selected tab panel
        document.getElementById(`${tabName}-panel`).classList.add('active');
        
        // Add active class to clicked tab
        event.target.classList.add('active');
    }
    
    function addParticipant(participant) {
        const participantsList = document.getElementById('participants-list');
        const participantDiv = document.createElement('div');
        participantDiv.className = `participant ${participant.user_type}`;
        participantDiv.id = `participant-${participant.user_id}`;
        
        const avatar = participant.user_name.charAt(0).toUpperCase();
        
        participantDiv.innerHTML = `
            <div class="participant-avatar">${avatar}</div>
            <div class="participant-info">
                <h4>${participant.user_name}</h4>
                <p>${participant.user_type}</p>
            </div>
        `;
        
        participantsList.appendChild(participantDiv);
    }
    
    function removeParticipant(userId) {
        // Remove peer connection
        const peerConnection = peerConnections.get(userId);
        if (peerConnection) {
            peerConnection.close();
            peerConnections.delete(userId);
        }
        
        // Remove video element
        const videoWrapper = document.getElementById(`wrapper-${userId}`);
        if (videoWrapper) {
            videoWrapper.remove();
        }
        
        // Remove participant from list
        const participantDiv = document.getElementById(`participant-${userId}`);
        if (participantDiv) {
            participantDiv.remove();
        }
    }
    
    function updateParticipantsList(participants) {
        const participantsList = document.getElementById('participants-list');
        participantsList.innerHTML = '';
        
        participants.forEach(participant => {
            addParticipant(participant);
        });
    }
    
    function addChatMessage(userName, message, timestamp, isOwn = false) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.style.marginBottom = '10px';
        messageDiv.style.padding = '8px';
        messageDiv.style.borderRadius = '5px';
        messageDiv.style.backgroundColor = isOwn ? '#007bff' : '#f8f9fa';
        messageDiv.style.color = isOwn ? 'white' : 'black';
        
        const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
        messageDiv.innerHTML = `<strong>${userName}:</strong> ${message} <small>(${time})</small>`;
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function sendChatMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        
        if (message && socket) {
            socket.emit('chat_message', {
                session_id: sessionId,
                message: message,
                user_id: currentUser.id,
                user_name: currentUser.name
            });
            
            input.value = '';
        }
    }
    
    // Poll Functions
    async function loadPolls() {
        if (!currentLectureId) {
            console.warn('No lecture ID available for loading polls');
            return;
        }
        
        console.log('Loading polls for lecture ID:', currentLectureId);
        
        try {
            const res = await fetch(`/api/lectures/${currentLectureId}/polls`, {
                credentials: 'same-origin'
            });
            const data = await res.json();
            
            console.log('Polls API response:', data);
            
            if (data.success) {
                polls = data.polls;
                console.log('Loaded polls:', polls);
                renderPolls();
            } else {
                console.error('Failed to load polls:', data.error);
            }
        } catch (error) {
            console.error('Failed to load polls:', error);
        }
    }
    
    function renderPolls() {
        const container = document.getElementById('polls-list');
        container.innerHTML = '';
        
        if (polls.length === 0) {
            container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No polls available</p>';
            return;
        }
        
        polls.forEach(poll => {
            addPollToUI(poll);
        });
    }
    
    function addPollToUI(poll) {
        const container = document.getElementById('polls-list');
        const pollDiv = document.createElement('div');
        pollDiv.className = 'poll-card';
        pollDiv.id = `poll-${poll.id}`;
        
        const hasVoted = userVotes.has(poll.id);
        const userVote = userVotes.get(poll.id);
        
        let optionsHTML = '';
        poll.options.forEach((option, index) => {
            const isSelected = hasVoted && userVote === option;
            optionsHTML += `
                <div class="poll-option ${isSelected ? 'selected' : ''}" 
                     onclick="voteOnPoll('${poll.id}', '${option}')">
                    <span class="poll-option-text">${option}</span>
                </div>
            `;
        });
        
        pollDiv.innerHTML = `
            <div class="poll-question">${poll.question}</div>
            <div class="poll-options">${optionsHTML}</div>
            <div class="poll-results" id="results-${poll.id}" style="display: ${hasVoted ? 'block' : 'none'};">
                <!-- Results will be populated here -->
            </div>
        `;
        
        container.appendChild(pollDiv);
    }
    
    function voteOnPoll(pollId, option) {
        if (userVotes.has(pollId)) {
            showAlert('You have already voted on this poll', 'error');
            return;
        }
        
        if (socket) {
            socket.emit('poll_vote', {
                session_id: sessionId,
                poll_id: pollId,
                option: option,
                user_id: currentUser.id
            });
            
            userVotes.set(pollId, option);
            showAlert('Vote submitted!', 'success');
            renderPolls(); // Refresh to show selection
        }
    }
    
    function updatePollResults(pollId, results) {
        // This would update the poll results in real-time
        renderPolls();
    }
    
    function addPollOption() {
        const optionsContainer = document.getElementById('poll-options');
        const optionCount = optionsContainer.children.length;
        
        const optionDiv = document.createElement('div');
        optionDiv.className = 'poll-option-input';
        optionDiv.innerHTML = `
            <input type="text" placeholder="Option ${optionCount + 1}" class="poll-option-text">
            <button onclick="removePollOption(this)">√ó</button>
        `;
        
        optionsContainer.appendChild(optionDiv);
    }
    
    function removePollOption(button) {
        if (document.getElementById('poll-options').children.length > 2) {
            button.parentElement.remove();
        }
    }
    
    async function createPoll() {
        const question = document.getElementById('poll-question').value.trim();
        const optionInputs = document.querySelectorAll('.poll-option-text');
        const options = Array.from(optionInputs).map(input => input.value.trim()).filter(option => option);
        
        if (!question) {
            showAlert('Please enter a poll question', 'error');
            return;
        }
        
        if (options.length < 2) {
            showAlert('Please enter at least 2 options', 'error');
            return;
        }
        
        try {
            const res = await fetch(`/api/lectures/${currentLectureId}/polls`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({
                    question: question,
                    options: options
                })
            });
            
            const data = await res.json();
            
            if (data.success) {
                showAlert('Poll created successfully!', 'success');
                document.getElementById('poll-question').value = '';
                optionInputs.forEach(input => input.value = '');
                loadPolls(); // Refresh polls
            } else {
                showAlert(data.error || 'Failed to create poll', 'error');
            }
        } catch (error) {
            showAlert('Failed to create poll: ' + error.message, 'error');
        }
    }
    
    function showError(message) {
        showAlert(message, 'error');
    }
    
    // Materials Functions
    async function loadMaterials() {
        if (!currentLectureId) {
            console.warn('No lecture ID available for loading materials');
            return;
        }
        
        console.log('Loading materials for lecture ID:', currentLectureId);
        
        try {
            const res = await fetch(`/api/teacher/lecture/${currentLectureId}/materials`, {
                credentials: 'same-origin'
            });
            const data = await res.json();
            
            console.log('Materials API response:', data);
            
            if (data.success) {
                renderMaterials(data.materials);
            } else {
                console.error('Failed to load materials:', data.error);
                document.getElementById('materials-list').innerHTML = '<p>Failed to load materials</p>';
            }
        } catch (error) {
            console.error('Failed to load materials:', error);
            document.getElementById('materials-list').innerHTML = '<p>Failed to load materials</p>';
        }
    }
    
    function renderMaterials(materials) {
        const container = document.getElementById('materials-list');
        
        if (!materials || materials.length === 0) {
            container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No materials available</p>';
            return;
        }
        
        container.innerHTML = materials.map(material => `
            <div class="material-item" style="padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin: 5px 0; background: #f8f9fa;">
                <h5 style="margin: 0 0 5px 0; color: #333;">${material.title}</h5>
                <p style="margin: 0 0 5px 0; font-size: 12px; color: #666;">${material.description || 'No description'}</p>
                <p style="margin: 0 0 10px 0; font-size: 11px; color: #999;">Uploaded: ${new Date(material.uploaded_at).toLocaleString()}</p>
                <div style="display: flex; gap: 5px;">
                    <a href="/api/download/${material.id}" class="btn" style="padding: 5px 10px; background: #007bff; color: white; text-decoration: none; border-radius: 3px; font-size: 12px;">üì• Download</a>
                    <button onclick="deleteMaterial('${material.id}')" class="btn" style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 3px; font-size: 12px; cursor: pointer;">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    async function deleteMaterial(materialId) {
        if (!confirm('Are you sure you want to delete this material?')) {
            return;
        }
        
        try {
            const res = await fetch(`/api/teacher/materials/${materialId}`, {
                method: 'DELETE',
                credentials: 'same-origin'
            });
            const data = await res.json();
            
            if (data.success) {
                showAlert('Material deleted successfully!', 'success');
                loadMaterials(); // Refresh materials list
            } else {
                showAlert(data.error || 'Failed to delete material', 'error');
            }
        } catch (error) {
            showAlert('Failed to delete material: ' + error.message, 'error');
        }
    }
    
    function showAlert(message, type) {
        const alert = document.getElementById('alert');
        alert.textContent = message;
        alert.className = `alert alert-${type}`;
        alert.style.display = 'block';
        
        setTimeout(() => {
            alert.style.display = 'none';
        }, 3000);
    }
</script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
